<div id="step" style="display:none">{{step}}</div>
<div id="sim_code" style="display:none">{{sim_code}}</div>
<div id="persona_name_list" style="display:none">{% for p_name, p_name_os in persona_names %}{{ p_name }}{% if not loop.last %},{% endif %}{% endfor %}</div>
<div id="persona_init_pos" style="display:none">
	{% for pos in persona_init_pos %}
		<span>{{pos[0]}},{{pos[1]}},{{pos[2]}}</span>
	{% endfor %}
</div>

<script type="text/javascript">
	/*
	  Main resources: 
	  https://www.youtube.com/watch?v=cKIG1lKwLeo&t=401s&ab_channel=HongLy
	  For the ground zero code, see the exported files from here: 
	  https://codepen.io/mikewesthad/pen/BVeoYP?editors=1111 

	  Also worth taking a look: 
	  https://www.youtube.com/watch?v=fdXcD9X4NrQ&ab_channel=MorganPage
	  and 
	  https://www.youtube.com/watch?v=MR2CvWxOEsw&ab_channel=MattWilber
	 */


	// ###########################################################################
	// PREAMBLE
	// ###########################################################################

	// <step> -- one full loop around all three phases determined by <phase> is 
	// a step. We use this to link the steps in the backend. 
	let step = parseInt(document.getElementById('step').innerHTML);
	let sim_code = document.getElementById('sim_code').innerHTML;
	// let persona_names = document.getElementById('persona_name_list').innerHTML.split(",");

	let spans = document.getElementById('persona_init_pos').getElementsByTagName('span');
	let persona_names = {};
	for(var i = 0, l = spans.length; i < l; i++){
		let x = spans[i].innerText.split(",");
		persona_names[x[0]] = [parseInt(x[1]), parseInt(x[2])]
	}

	// Phaser 3.0 global settings. 
	// Configuration meant to be passed to the main Phaser game instance. 
	// Using larger viewport with zoom controls to view full town
	const config = {
	  type: Phaser.AUTO,
	  width: 1500,
	  height: 800,
	  parent: "game-container",
	  pixelArt: true,
	  physics: {
	    default: "arcade",
	    arcade: {
	      gravity: { y: 0 } } },
	  scene: {
	    preload: preload,
	    create: create,
	    update: update } };

	// Zoom control variables
	let currentZoom = 0.5;
	const minZoom = 0.2;
	const maxZoom = 2.0;
	const zoomStep = 0.1;

	// Camera and agent variables (global scope for Phaser functions)
	let followingAgent = null;
	let freeCameraSpeed = 300;
	let wasdKeys;

	// Function to update zoom level display (global scope)
	function updateZoomDisplay() {
		const zoomElement = document.getElementById('zoom-level');
		if (zoomElement) {
			zoomElement.textContent = `${currentZoom.toFixed(1)}x`;
		}
	}

	// Creating the game instance and setting up the main Phaser variables that  
	// will be used in it. 
	console.log("Phaser: Creating game instance...");
	const game = new Phaser.Game(config);
	console.log("Phaser: Game instance created");
	let cursors;
	let player;
	let showDebug = false;

	// Persona related variables. This should have the name of the persona as its 
	// keys, and the instances of the Persona class as the values.
	var spawn_tile_loc = {};

	for (var key in persona_names){
		spawn_tile_loc[key] = persona_names[key] ;
	}
	console.log("Spawn locations:", spawn_tile_loc);

	var personas = {};
	var pronunciatios = {};
	let anims_direction;
	let pre_anims_direction;
	let pre_anims_direction_dict = {};

	let curr_maze = "the_ville";

	// <tile_width> is the width of one individual tile (tiles are square)
	let tile_width = 32;
	// Important: tile_width % movement_speed has to be 0. 
	// <movement_speed> determines how fast we move at each upate cylce. 
	let movement_speed = 32; 

	// <timer_max> determines how frequently our update function will query the 
	// frontend server. If it's higher, we wait longer cycles. 
	let timer_max = 0;
	let timer = timer_max;

	// <phase> -- there are three phases: "process," "update," and "execute."
	let phase = "update"; // or "update" or "execute"

	// Variables for storing movements that are sent from the backend server.
	let execute_movement;
	let execute_count_max = tile_width/movement_speed;
	let execute_count = execute_count_max;
	let movement_target = {};

	// ###########################################################################
	// PERSONA CLASS
	// ###########################################################################

	// This persona class defines the agents in the games. 
	class Persona {

		constructor (scene, x, y, texture, frame, p_name) {

			this.scene = scene
			this.p_name = p_name

			// Phaser sprite creation
			this.sprite = scene.physics.add.sprite(x, y, texture, frame);

			// Setting the persona's profile pic
			// For now, we are giving everyone the same pic. 
			this.sprite.setTexture("atlas", "misa-front")

			// Setting the scale of the character. 
			this.sprite.setScale(1.0);

			// Setting collision boundaries
			this.sprite.body.setSize(this.sprite.width * 0.8, this.sprite.height * 0.8);

			// Movement variables
			this.prevVelocity = {x: 0, y: 0};

			this.temp_x = x;
			this.temp_y = y;

			this.curr_move = [this.temp_x, this.temp_y];

		}

		new_move(x_y) {
			this.temp_x = x_y[0] * 32 + 16;
			this.temp_y = x_y[1] * 32 + 16;
			this.curr_move = [this.temp_x, this.temp_y];
		}

		update() {

			let x_distance = Math.abs(this.sprite.body.x - (this.temp_x-this.sprite.width/2));
			let y_distance = Math.abs(this.sprite.body.y - (this.temp_y-this.sprite.height+4));

			if (x_distance < 3 && y_distance < 3) {
				this.sprite.body.setVelocity(0);
				return;
			}

			const speed = 60;
			const prevVelocity = this.sprite.body.velocity.clone();

			// Stop any previous movement from the last frame
			this.sprite.body.setVelocity(0);

			let direction = {x: 0, y: 0};

			if (this.sprite.body.x > this.temp_x-this.sprite.width/2) {
				direction.x = -1;
			} else if (this.sprite.body.x < this.temp_x-this.sprite.width/2) {
				direction.x = 1;
			}

			if (this.sprite.body.y > this.temp_y-this.sprite.height+4) {
				direction.y = -1;
			} else if (this.sprite.body.y < this.temp_y-this.sprite.height+4) {
				direction.y = 1;
			}

			// Normalize diagonal movement
			if (direction.x !== 0 && direction.y !== 0) {
				direction.x *= 0.707;
				direction.y *= 0.707;
			}

			this.sprite.body.setVelocity(speed * direction.x, speed * direction.y);

			// Update animations
			if (this.sprite.body.velocity.x < 0) {
				this.sprite.anims.play("misa-left-walk", true);
			} else if (this.sprite.body.velocity.x > 0) {
				this.sprite.anims.play("misa-right-walk", true);
			} else if (this.sprite.body.velocity.y < 0) {
				this.sprite.anims.play("misa-back-walk", true);
			} else if (this.sprite.body.velocity.y > 0) {
				this.sprite.anims.play("misa-front-walk", true);
			} else {
				this.sprite.anims.stop();
				if (prevVelocity.x < 0) this.sprite.setTexture("atlas", "misa-left");
				else if (prevVelocity.x > 0) this.sprite.setTexture("atlas", "misa-right");
				else if (prevVelocity.y < 0) this.sprite.setTexture("atlas", "misa-back");
				else if (prevVelocity.y > 0) this.sprite.setTexture("atlas", "misa-front");
			}
		}
	}

	// ###########################################################################
	// PHASER FUNCTIONS
	// ###########################################################################

	function preload() {  
		console.log("Phaser: Starting preload...");
		// Loading the necessary images (e.g., the background image, character 
		// sprites). 

		// Load all required tileset images
		this.load.image("blocks_1", "/static/assets/the_ville/visuals/map_assets/blocks/blocks_1.png");
		this.load.image("walls", "/static/assets/the_ville/visuals/map_assets/v1/Room_Builder_32x32.png");
		this.load.image("interiors_pt1", "/static/assets/the_ville/visuals/map_assets/v1/interiors_pt1.png");
		this.load.image("interiors_pt2", "/static/assets/the_ville/visuals/map_assets/v1/interiors_pt2.png");
		this.load.image("interiors_pt3", "/static/assets/the_ville/visuals/map_assets/v1/interiors_pt3.png");
		this.load.image("interiors_pt4", "/static/assets/the_ville/visuals/map_assets/v1/interiors_pt4.png");
		this.load.image("interiors_pt5", "/static/assets/the_ville/visuals/map_assets/v1/interiors_pt5.png");
		this.load.image("CuteRPG_Field_B", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Field_B.png");
		this.load.image("CuteRPG_Field_C", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Field_C.png");
		this.load.image("CuteRPG_Harbor_C", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Harbor_C.png");
		this.load.image("CuteRPG_Village_B", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Village_B.png");
		this.load.image("CuteRPG_Forest_B", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Forest_B.png");
		this.load.image("CuteRPG_Desert_C", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Desert_C.png");
		this.load.image("CuteRPG_Mountains_B", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Mountains_B.png");
		this.load.image("CuteRPG_Desert_B", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Desert_B.png");
		this.load.image("CuteRPG_Forest_C", "/static/assets/the_ville/visuals/map_assets/cute_rpg_word_VXAce/tilesets/CuteRPG_Forest_C.png");

		// Load the full tilemap JSON (using the same one as original Django)
		this.load.tilemapTiledJSON("map", "/static/assets/the_ville/visuals/the_ville_jan7.json");

		// Load character atlas - use external atlas like original Django version
		this.load.atlas("atlas", 
			"https://mikewesthad.github.io/phaser-3-tilemap-blog-posts/post-1/assets/atlas/atlas.png", 
			"https://mikewesthad.github.io/phaser-3-tilemap-blog-posts/post-1/assets/atlas/atlas.json");
	}

	function create() {  
		console.log("Phaser: Starting create...");
		const map = this.make.tilemap({ key: "map" });

		// Add all tilesets with their corresponding images
		const collisions = map.addTilesetImage("blocks", "blocks_1");
		const walls = map.addTilesetImage("Room_Builder_32x32", "walls");
		const interiors_pt1 = map.addTilesetImage("interiors_pt1", "interiors_pt1");
		const interiors_pt2 = map.addTilesetImage("interiors_pt2", "interiors_pt2");
		const interiors_pt3 = map.addTilesetImage("interiors_pt3", "interiors_pt3");
		const interiors_pt4 = map.addTilesetImage("interiors_pt4", "interiors_pt4");
		const interiors_pt5 = map.addTilesetImage("interiors_pt5", "interiors_pt5");
		const CuteRPG_Field_B = map.addTilesetImage("CuteRPG_Field_B", "CuteRPG_Field_B");
		const CuteRPG_Field_C = map.addTilesetImage("CuteRPG_Field_C", "CuteRPG_Field_C");
		const CuteRPG_Harbor_C = map.addTilesetImage("CuteRPG_Harbor_C", "CuteRPG_Harbor_C");
		const CuteRPG_Village_B = map.addTilesetImage("CuteRPG_Village_B", "CuteRPG_Village_B");
		const CuteRPG_Forest_B = map.addTilesetImage("CuteRPG_Forest_B", "CuteRPG_Forest_B");
		const CuteRPG_Desert_C = map.addTilesetImage("CuteRPG_Desert_C", "CuteRPG_Desert_C");
		const CuteRPG_Mountains_B = map.addTilesetImage("CuteRPG_Mountains_B", "CuteRPG_Mountains_B");
		const CuteRPG_Desert_B = map.addTilesetImage("CuteRPG_Desert_B", "CuteRPG_Desert_B");
		const CuteRPG_Forest_C = map.addTilesetImage("CuteRPG_Forest_C", "CuteRPG_Forest_C");

		// Create tileset groups like original Django version
		let tileset_group_1 = [CuteRPG_Field_B, CuteRPG_Field_C, CuteRPG_Harbor_C, CuteRPG_Village_B, 
			CuteRPG_Forest_B, CuteRPG_Desert_C, CuteRPG_Mountains_B, CuteRPG_Desert_B, CuteRPG_Forest_C,
			interiors_pt1, interiors_pt2, interiors_pt3, interiors_pt4, interiors_pt5, walls];

		// Create all layers using the proper tileset groups
		const bottomGroundLayer = map.createLayer("Bottom Ground", tileset_group_1, 0, 0);
		const exteriorGroundLayer = map.createLayer("Exterior Ground", tileset_group_1, 0, 0);
		const exteriorDecorationL1Layer = map.createLayer("Exterior Decoration L1", tileset_group_1, 0, 0);
		const exteriorDecorationL2Layer = map.createLayer("Exterior Decoration L2", tileset_group_1, 0, 0);
		const interiorGroundLayer = map.createLayer("Interior Ground", tileset_group_1, 0, 0);
		const wallLayer = map.createLayer("Wall", [CuteRPG_Field_C, walls], 0, 0);
		const interiorFurnitureL1Layer = map.createLayer("Interior Furniture L1", tileset_group_1, 0, 0);
		const interiorFurnitureL2Layer = map.createLayer("Interior Furniture L2 ", tileset_group_1, 0, 0);
		const foregroundL1Layer = map.createLayer("Foreground L1", tileset_group_1, 0, 0);
		const foregroundL2Layer = map.createLayer("Foreground L2", tileset_group_1, 0, 0);
		
		// Set proper depths for foreground layers
		foregroundL1Layer.setDepth(2);
		foregroundL2Layer.setDepth(2);

		// Create collision layer
		const collisionsLayer = map.createLayer("Collisions", collisions, 0, 0);
		
		// Set collision properties
		collisionsLayer.setCollisionByProperty({ collide: true });
		collisionsLayer.setDepth(-1);

		// *** SET UP CAMERA *** 
		// Setting up free camera system with agent following capability
		const camera = this.cameras.main;
		camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
		
		// Camera variables are now global
		
		// Set initial camera position and zoom
		camera.setScroll(2240 - 750, 1600 - 400); // Center on map
		camera.setZoom(currentZoom);
		
		// Set up keyboard controls
		cursors = this.input.keyboard.createCursorKeys();
		
		// Add WASD controls for free camera movement
		wasdKeys = this.input.keyboard.addKeys('W,S,A,D');
		
		// Add escape key to stop following any agent
		const escapeKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);
		
		// Add zoom controls (+ and - keys, as well as = and - for convenience)
		const plusKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.PLUS);
		const minusKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.MINUS);
		const equalsKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.EQUALS); // For + without shift
		
		// Zoom in controls
		plusKey.on('down', () => {
			currentZoom = Math.min(currentZoom + zoomStep, maxZoom);
			camera.setZoom(currentZoom);
			updateZoomDisplay();
			console.log(`Zoom: ${currentZoom.toFixed(1)}x`);
		});
		
		equalsKey.on('down', () => {
			currentZoom = Math.min(currentZoom + zoomStep, maxZoom);
			camera.setZoom(currentZoom);
			updateZoomDisplay();
			console.log(`Zoom: ${currentZoom.toFixed(1)}x`);
		});
		
		// Zoom out control
		minusKey.on('down', () => {
			currentZoom = Math.max(currentZoom - zoomStep, minZoom);
			camera.setZoom(currentZoom);
			updateZoomDisplay();
			console.log(`Zoom: ${currentZoom.toFixed(1)}x`);
		});
		
		// Escape key to stop following any agent
		escapeKey.on('down', () => {
			if (followingAgent) {
				followingAgent = null;
				currentlyFollowing = null;
				updateFollowingDisplay();
				console.log("Camera: Stopped following agent. Free camera mode.");
			}
		});
		
		// Function to start following a specific agent
		window.followAgent = function(agentName) {
			if (personas[agentName]) {
				followingAgent = agentName;
				console.log(`Camera: Now following ${agentName}. Press ESC to stop following.`);
			}
		};
		
		// Make variables accessible globally for debugging
		window.debugPhaser = {
			camera: camera,
			personas: personas,
			followingAgent: () => followingAgent
		};
		
		// Update initial zoom display
		updateZoomDisplay();

		// *** SET UP PERSONAS *** 
		// We start by creating the game sprite objects. 
		for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) { 
			let persona_name = Object.keys(spawn_tile_loc)[i];
			let start_pos = [spawn_tile_loc[persona_name][0] * tile_width + tile_width / 2, 
				spawn_tile_loc[persona_name][1] * tile_width + tile_width];
			
			// Create Persona class instance (not just a sprite)
			personas[persona_name] = new Persona(this, start_pos[0], start_pos[1], "atlas", "misa-front", persona_name);
			
			// Get the sprite from the persona for speech bubble positioning
			let new_sprite = personas[persona_name].sprite;
			// Create agent initials for speech bubble
			let rgx = new RegExp(/(\p{L}{1})\p{L}+/, 'gu');
			let initials = [...persona_name.matchAll(rgx)] || [];
			initials = (
				(initials.shift()?.[1] || '') + (initials.pop()?.[1] || '')
			).toUpperCase();

			pronunciatios[persona_name] = this.add.text(
				new_sprite.body.x - 6, 
				new_sprite.body.y - 42 - 32,
				initials + ": idle", {
				font: "24px Arial", 
				fill: "#000000", 
				padding: { x: 15, y: 10}, 
				backgroundColor: "#ffffff",
				border:"solid",
				borderRadius:"15px",
				wordWrap: { width: 300, useAdvancedWrap: true }
			}).setDepth(3);
		}

		// Create the player's walking animations from the texture atlas. These are
		// stored in the global animation manager so any sprite can access them.
		const anims = this.anims;
		anims.create({
			key: "misa-left-walk",
			frames: anims.generateFrameNames("atlas", { prefix: "misa-left-walk.", start: 0, end: 3, zeroPad: 3 }),
			frameRate: 4,
			repeat: -1 });

		anims.create({
			key: "misa-right-walk",
			frames: anims.generateFrameNames("atlas", { prefix: "misa-right-walk.", start: 0, end: 3, zeroPad: 3 }),
			frameRate: 4,
			repeat: -1 });

		anims.create({
			key: "misa-front-walk",
			frames: anims.generateFrameNames("atlas", { prefix: "misa-front-walk.", start: 0, end: 3, zeroPad: 3 }),
			frameRate: 4,
			repeat: -1 });

		anims.create({
			key: "misa-back-walk",
			frames: anims.generateFrameNames("atlas", { prefix: "misa-back-walk.", start: 0, end: 3, zeroPad: 3 }),
			frameRate: 4,
			repeat: -1 });
	}

	function update(time, delta) {
		// Update all personas and their speech bubbles
		for (var persona_name in personas) {
			personas[persona_name].update();
			
			// Update speech bubble position to follow agent
			if (pronunciatios[persona_name] && personas[persona_name]) {
				pronunciatios[persona_name].x = personas[persona_name].sprite.body.x - 6;
				pronunciatios[persona_name].y = personas[persona_name].sprite.body.y - 42 - 32;
			}
		}

		// Camera controls
		const cam = this.cameras.main;
		
		if (followingAgent && personas[followingAgent]) {
			// Follow specific agent smoothly
			const targetAgent = personas[followingAgent].sprite;
			const targetX = targetAgent.body.x - cam.width / 2 / cam.zoom;
			const targetY = targetAgent.body.y - cam.height / 2 / cam.zoom;
			
			// Smooth camera following with lerp
			const lerpSpeed = 0.05; // Adjust for smoother/faster following
			cam.scrollX += (targetX - cam.scrollX) * lerpSpeed;
			cam.scrollY += (targetY - cam.scrollY) * lerpSpeed;
		} else {
			// Free camera mode with WASD/Arrow controls
			const speed = freeCameraSpeed * (1 / currentZoom); // Adjust speed based on zoom level
			
			if (wasdKeys.A.isDown || cursors.left.isDown) {
				cam.scrollX -= speed * delta / 1000;
			}
			if (wasdKeys.D.isDown || cursors.right.isDown) {
				cam.scrollX += speed * delta / 1000;
			}
			if (wasdKeys.W.isDown || cursors.up.isDown) {
				cam.scrollY -= speed * delta / 1000;
			}
			if (wasdKeys.S.isDown || cursors.down.isDown) {
				cam.scrollY += speed * delta / 1000;
			}
		}
	}

	// ###########################################################################
	// SIMULATION MANAGEMENT
	// ###########################################################################

	let currentStep = step;
	let isPlaying = false;

	function startSimulation() {
		console.log("Starting simulation...");
		isPlaying = true;
		updateSimulation();
	}

	function pauseSimulation() {
		console.log("Pausing simulation...");
		isPlaying = false;
	}

	async function updateSimulation() {
		if (!isPlaying) return;

		try {
			// Get movement updates from backend
			const response = await fetch('/update_environment/', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({
					step: currentStep,
					sim_code: sim_code
				})
			});

			const data = await response.json();

			if (data["<step>"] !== -1) {
				// Update agent positions and info
				for (let persona_name in data) {
					if (persona_name !== "<step>" && personas[persona_name]) {
						let movement = data[persona_name].movement;
						personas[persona_name].new_move([movement[0], movement[1]]);

						// Update UI elements
						let persona_name_underscore = persona_name.replace(" ", "_");
						let actionElement = document.getElementById("current_action__" + persona_name_underscore);
						let addressElement = document.getElementById("target_address__" + persona_name_underscore);
						let chatElement = document.getElementById("chat__" + persona_name_underscore);

						if (actionElement) actionElement.innerHTML = data[persona_name].pronunciatio || "idle";
						if (addressElement) addressElement.innerHTML = data[persona_name].scratch?.curr_tile?.[0] || "unknown";
						if (chatElement) chatElement.innerHTML = data[persona_name].chat || "";

						// Update speech bubbles with richer content
						if (pronunciatios[persona_name]) {
							let bubbleText = "";
							let agentAction = data[persona_name].pronunciatio || "idle";
							let agentChat = data[persona_name].chat || "";
							
							// Create agent initials
							let rgx = new RegExp(/(\p{L}{1})\p{L}+/, 'gu');
							let initials = [...persona_name.matchAll(rgx)] || [];
							initials = (
								(initials.shift()?.[1] || '') + (initials.pop()?.[1] || '')
							).toUpperCase();

							// Show chat if available, otherwise show action
							if (agentChat && agentChat.trim() !== "") {
								bubbleText = initials + ": " + agentChat;
							} else {
								bubbleText = initials + ": " + agentAction;
							}

							pronunciatios[persona_name].setText(bubbleText);
						}
					}
				}

				currentStep++;
			}

		} catch (error) {
			console.error('Error updating simulation:', error);
		}

		// Continue updating if still playing
		if (isPlaying) {
			setTimeout(updateSimulation, 2000); // Update every 2 seconds
		}
	}

	// Agent following management
	let currentlyFollowing = null;
	
	function updateFollowingDisplay() {
		const followingText = document.getElementById('following-agent');
		if (followingText) {
			followingText.textContent = currentlyFollowing ? currentlyFollowing : "Free Camera";
		}
	}

	// Button event listeners
	document.addEventListener('DOMContentLoaded', function() {
		const playButton = document.getElementById('play_button');
		const pauseButton = document.getElementById('pause_button');
		const zoomFullButton = document.getElementById('zoom-full');
		const zoomNormalButton = document.getElementById('zoom-normal');
		const centerCameraButton = document.getElementById('center-camera');
		const stopFollowingButton = document.getElementById('stop-following');
		const followAgentButtons = document.querySelectorAll('.follow-agent-btn');

		if (playButton) {
			playButton.addEventListener('click', startSimulation);
		}

		if (pauseButton) {
			pauseButton.addEventListener('click', pauseSimulation);
		}

		// Zoom preset buttons
		if (zoomFullButton) {
			zoomFullButton.addEventListener('click', function() {
				// Set zoom to show full ville (very zoomed out)
				currentZoom = 0.25;
				const camera = game.scene.scenes[0].cameras.main;
				camera.setZoom(currentZoom);
				updateZoomDisplay();
				console.log(`Zoom preset: Full Ville View (${currentZoom}x)`);
			});
		}

		if (zoomNormalButton) {
			zoomNormalButton.addEventListener('click', function() {
				// Set zoom to normal detailed view
				currentZoom = 0.8;
				const camera = game.scene.scenes[0].cameras.main;
				camera.setZoom(currentZoom);
				updateZoomDisplay();
				console.log(`Zoom preset: Normal View (${currentZoom}x)`);
			});
		}

		// Center camera button
		if (centerCameraButton) {
			centerCameraButton.addEventListener('click', function() {
				const camera = game.scene.scenes[0].cameras.main;
				// Center the free camera on ville
				camera.setScroll(2240 - 750, 1600 - 400);
				// Stop following any agent
				currentlyFollowing = null;
				if (game.scene.scenes[0]) {
					game.scene.scenes[0].followingAgent = null;
				}
				updateFollowingDisplay();
				console.log("Camera centered on ville");
			});
		}

		// Stop following button
		if (stopFollowingButton) {
			stopFollowingButton.addEventListener('click', function() {
				currentlyFollowing = null;
				if (game.scene.scenes[0]) {
					game.scene.scenes[0].followingAgent = null;
				}
				updateFollowingDisplay();
				console.log("Stopped following agent. Free camera mode.");
			});
		}

		// Agent follow buttons
		followAgentButtons.forEach(button => {
			button.addEventListener('click', function() {
				const agentName = this.getAttribute('data-agent');
				currentlyFollowing = agentName;
				
				// Call the global followAgent function
				if (window.followAgent) {
					window.followAgent(agentName);
				}
				
				// Update the scene's following variable
				if (game.scene.scenes[0]) {
					game.scene.scenes[0].followingAgent = agentName;
				}
				
				updateFollowingDisplay();
				console.log(`Now following ${agentName}`);
			});
		});

		// Auto-start if in simulate mode
		if ('{{mode}}' === 'simulate') {
			setTimeout(() => {
				startSimulation();
			}, 2000);
		}

		console.log("Dating Show simulation initialized");
	});

</script>